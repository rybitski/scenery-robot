/*
This program is able to constantly read commands from an
xbox controller. It immediately turns the motors according
to those values. While it's turning, it's also recording the
encoder ticks generated by these turns.
*/

#include <SPI.h>
#include <EthernetV2_0.h>
#include <EthernetUdpV2_0.h>
#include <Sabertooth.h>
#include <stdint.h>

const int SDCARD_CS_PIN = 4; // SD card chip select
const int W5200_CS_PIN = 10; // ethernet card chip select

// Slave Select pins for encoders 1 and 2
// Feel free to reallocate these pins to best suit your circuit
const int ENCODER_1_SS_PIN = 7;
const int ENCODER_2_SS_PIN = 8;

// These hold the current encoder count.
signed long encoder1Count = 0;
signed long encoder2Count = 0;

// server stuff
byte mac[] = {0x62, 0x02, 0x69, 0x9E, 0xC4, 0xFF};
const int TCP_PORT = 29281;
const int UDP_PORT = 29282;
IPAddress ip(192, 168, 1, 3);
EthernetClient client;
EthernetUDP Udp;

// buffers for receiving and sending UDP data
char packetBuffer[UDP_TX_PACKET_MAX_SIZE]; //buffer to hold incoming packet,
char replyBuffer[] = "acknowledged";       // a string to send back

int8_t leftMotorPower; // between -127 and 127, to match Sabertooth controller
int8_t rightMotorPower; // between -127 and 127, to match Sabertooth controller

Sabertooth ST(128);

const int PATH_BUFFER_SIZE = 32;
long pathBuffer[PATH_BUFFER_SIZE][2];
unsigned int pathBufferIndex = 0;

typedef enum {manual, recording, playback} RobotState;
RobotState robotState = recording;

const float LEFT_MOTOR_K_P = .01;
const float LEFT_MOTOR_K_I = 0;
const float LEFT_MOTOR_K_D = 0;
const float RIGHT_MOTOR_K_P = .01;
const float RIGHT_MOTOR_K_I = 0;
const float RIGHT_MOTOR_K_D = 0;
signed long leftError = 0;
signed long oldLeftError = 0;
signed long diffLeftError = 0;
signed long sumLeftError = 0;
signed long rightError = 0;
signed long oldRightError = 0;
signed long diffRightError = 0;
signed long sumRightError = 0;

void initEncoders(void) {
	// Set slave selects as outputs
	pinMode(ENCODER_1_SS_PIN, OUTPUT);
	pinMode(ENCODER_2_SS_PIN, OUTPUT);

	// Raise select pins
	// Communication begins when you drop the individual select signsl
	digitalWrite(ENCODER_1_SS_PIN, HIGH);
	digitalWrite(ENCODER_2_SS_PIN, HIGH);

	SPI.begin();

	// Initialize encoder 1
	//    Clock division factor: 0
	//    Negative index input
	//    free-running count mode
	//    x4 quatrature count mode (four counts per quadrature cycle)
	// NOTE: For more information on commands, see datasheet
	digitalWrite(ENCODER_1_SS_PIN, LOW);        // Begin SPI conversation
	SPI.transfer(0x88);                       // Write to MDR0
	SPI.transfer(0x03);                       // Configure to 4 byte mode
	digitalWrite(ENCODER_1_SS_PIN, HIGH);       // Terminate SPI conversation

	// Initialize encoder 2
	//    Clock division factor: 0
	//    Negative index input
	//    free-running count mode
	//    x4 quatrature count mode (four counts per quadrature cycle)
	// NOTE: For more information on commands, see datasheet
	digitalWrite(ENCODER_2_SS_PIN, LOW);        // Begin SPI conversation
	SPI.transfer(0x88);                       // Write to MDR0
	SPI.transfer(0x03);                       // Configure to 4 byte mode
	digitalWrite(ENCODER_2_SS_PIN, HIGH);       // Terminate SPI conversation
}

long readEncoder(int encoder) {
	// Initialize temporary variables for SPI read
	unsigned int count1, count2, count3, count4;
	long countValue;

	// Read encoder 1
	if (encoder == 1) {
		digitalWrite(ENCODER_1_SS_PIN, LOW);      // Begin SPI conversation
		SPI.transfer(0x60);                     // Request count
		count1 = SPI.transfer(0x00);           // Read highest order byte
		count2 = SPI.transfer(0x00);
		count3 = SPI.transfer(0x00);
		count4 = SPI.transfer(0x00);           // Read lowest order byte
		digitalWrite(ENCODER_1_SS_PIN, HIGH);     // Terminate SPI conversation
	}

	// Read encoder 2
	else if (encoder == 2) {
		digitalWrite(ENCODER_2_SS_PIN, LOW);      // Begin SPI conversation
		SPI.transfer(0x60);                      // Request count
		count1 = SPI.transfer(0x00);           // Read highest order byte
		count2 = SPI.transfer(0x00);
		count3 = SPI.transfer(0x00);
		count4 = SPI.transfer(0x00);           // Read lowest order byte
		digitalWrite(ENCODER_2_SS_PIN, HIGH);     // Terminate SPI conversation
	}

	// Calculate encoder count
	countValue = (count1 << 8) + count2;
	countValue = (countValue << 8) + count3;
	countValue = (countValue << 8) + count4;

	return countValue;
}

void clearEncoderCount(void) {
	// Set encoder1's data register to 0
	digitalWrite(ENCODER_1_SS_PIN, LOW);      // Begin SPI conversation
	// Write to DTR
	SPI.transfer(0x98);
	// Load data
	SPI.transfer(0x00);  // Highest order byte
	SPI.transfer(0x00);
	SPI.transfer(0x00);
	SPI.transfer(0x00);  // lowest order byte
	digitalWrite(ENCODER_1_SS_PIN, HIGH);     // Terminate SPI conversation

	delayMicroseconds(100);  // provides some breathing room between SPI conversations

	// Set encoder1's current data register to center
	digitalWrite(ENCODER_1_SS_PIN, LOW);      // Begin SPI conversation
	SPI.transfer(0xE0);
	digitalWrite(ENCODER_1_SS_PIN, HIGH);     // Terminate SPI conversation

	// Set encoder2's data register to 0
	digitalWrite(ENCODER_2_SS_PIN, LOW);      // Begin SPI conversation
	// Write to DTR
	SPI.transfer(0x98);
	// Load data
	SPI.transfer(0x00);  // Highest order byte
	SPI.transfer(0x00);
	SPI.transfer(0x00);
	SPI.transfer(0x00);  // lowest order byte
	digitalWrite(ENCODER_2_SS_PIN, HIGH);     // Terminate SPI conversation

	delayMicroseconds(100);  // provides some breathing room between SPI conversations

	// Set encoder2's current data register to center
	digitalWrite(ENCODER_2_SS_PIN, LOW);      // Begin SPI conversation
	SPI.transfer(0xE0);
	digitalWrite(ENCODER_2_SS_PIN, HIGH);     // Terminate SPI conversation
}

void setup(void) {
	Serial.begin(9600);

	Serial.println("Begin setup()");
	Serial.println("We are the client.");

	initEncoders();       Serial.println("Encoders initialized.");
	clearEncoderCount();  Serial.println("Encoders cleared.");

	// Set chip select high (inactive) for SD card.
	pinMode(SDCARD_CS_PIN, OUTPUT);
	digitalWrite(SDCARD_CS_PIN, HIGH);

	// start the Ethernet connection:
	Serial.print("Configuring Ethernet client using static IP... ");
	Ethernet.begin(mac, ip);
	Serial.print("Success. ");

	delay(1000); // give the Ethernet sheild a second to initialize

	// print your local IP address:
	Serial.print("My IP address: ");
	for (byte thisByte = 0; thisByte < 4; thisByte++) {
	  // print the value of each byte of the IP address:
	  Serial.print(Ethernet.localIP()[thisByte], DEC);
	  Serial.print("."); 
	}
	Serial.println();

	char serverName[] = "192.168.1.2";
	Serial.print("Trying to connect to ");
	Serial.print(serverName);
	Serial.print(":");
	Serial.print(TCP_PORT);
	Serial.print("... ");
	if (client.connect(serverName, TCP_PORT)) {
		Serial.println("connected.");
		client.print("Hi. My name is ");
		client.print(Ethernet.localIP());
		client.println(". Thx for letting me connect.");
		client.println();
	}
	else {
		Serial.println("failed.");
	}

	SabertoothTXPinSerial.begin(9600);
	ST.autobaud();

	Udp.begin(UDP_PORT);
	
	Serial.println("Done with setup()");
}

void loop(void) {
	// Output state to serial monitor
	Serial.print("Enc1: ");
	Serial.print(encoder1Count);
	Serial.print(" Enc2: ");
	Serial.print(encoder2Count);

	Serial.print(" leftMotorPower: ");
	Serial.print(leftMotorPower);
	Serial.print(" rightMotorPower: ");
	Serial.println(rightMotorPower);

	// Retrieve current encoder counters
	encoder1Count = readEncoder(1);
	encoder2Count = readEncoder(2);

	// if there's data available, read a packet
	int packetSize = Udp.parsePacket();
	if (packetSize) {
		// read the packet into the buffer
		Udp.read(packetBuffer, 12);

		// read command from UDP packet

		// send a reply, to the IP address and port that sent us the packet we just got
		// Udp.beginPacket(Udp.remoteIP(), Udp.remotePort());
		// Udp.write(replyBuffer);
		// Udp.endPacket();
	}

	// switch statement determines how to update motors & what to do with encoder counts
	switch (robotState) {
		case recording:
			Serial.print("Record mode: ");
			memcpy(&leftMotorPower, &packetBuffer[4], 1);
			memcpy(&rightMotorPower, &packetBuffer[5], 1);
			pathBuffer[pathBufferIndex][0] = encoder1Count;
			pathBuffer[pathBufferIndex][1] = encoder2Count;

			// if buffer is full, send it off to server and clear it
			// also start bufferIndex back at 0 to so it can be refilled
			if (++pathBufferIndex == PATH_BUFFER_SIZE) {
				Serial.println("PATH BUFFER IS FULL: SENDING OVER TCP");
				for (int i = 0; i < PATH_BUFFER_SIZE; i++) {
					for (int j = 0; j < 2; j++) {
						byte data[4];
						memcpy(data, &pathBuffer[i][j], 4);
						client.write(data, 4); // 4 bytes per cell (longs)
					}
				}
				pathBufferIndex = 0;
			}
			break;
		case manual:
			Serial.print("Manual mode: ");
			memcpy(&leftMotorPower, &packetBuffer[4], 1);
			memcpy(&rightMotorPower, &packetBuffer[5], 1);

			// if command is now to start recording
				// set state to recording
				// start buffer index at 0
				pathBufferIndex = 0;
			// else if command now is playback
				// set state to playback
				// start buffer index at PATH_BUFFER_SIZE - 1 (so ++incrementer makes it start at 0)

			break;
		case playback:
			// instead of writing to the pathBuffer (as we do in recording)
			// now, we read from it.
			
			Serial.print("Playback mode: ");

			// if we have read until the end of the pathBuffer, ask server for more
			// also start bufferIndex back at 0 to continue reading from top
			if (++pathBufferIndex == PATH_BUFFER_SIZE) {
				Serial.println("BUFFER COMPLETELY PROCESSED: REQUESTING MORE");
				for (int i = 0; i < PATH_BUFFER_SIZE; i++) {
					for (int j = 0; j < 2; j++) {
						long data = 0;

						// TODO: May need to switch this order
						data |= (client.read() << 0);
						data |= (client.read() << 8);
						data |= (client.read() << 16);
						data |= (client.read() << 24);
						pathBuffer[i][j] = data;
					}
				}
				pathBufferIndex = 0;
			}

			// based on
				// current encoder ticks since playback start
				// stated encoder ticks at this timestep in path buffer

			// set motor powers to PID
			oldLeftError = leftError;
			leftError = encoder1Count - pathBuffer[pathBufferIndex][0];
			diffLeftError = leftError - oldLeftError;
			sumLeftError += leftError;

			oldRightError = rightError;
			rightError = encoder2Count - pathBuffer[pathBufferIndex][1];
			diffRightError = rightError - oldRightError;
			sumRightError += rightError;

			leftMotorPower = (int8_t)(LEFT_MOTOR_K_P * leftError + LEFT_MOTOR_K_I * sumLeftError + LEFT_MOTOR_K_D * diffLeftError);
			rightMotorPower = (int8_t)(RIGHT_MOTOR_K_P * rightError + RIGHT_MOTOR_K_I * sumRightError + RIGHT_MOTOR_K_D * diffRightError);
			
			if (leftMotorPower > 127) leftMotorPower = 127;
			if (rightMotorPower > 127) rightMotorPower = 127;
			if (leftMotorPower < -127) leftMotorPower = -127;
			if (rightMotorPower < -127) rightMotorPower = -127;

			break;
		default:
			break;
	}

	// update motors
	ST.motor(1, leftMotorPower);
	ST.motor(2, rightMotorPower);

	Serial.print(" motor1=");
	Serial.print(leftMotorPower);
	Serial.print(" motor2=");
	Serial.println(rightMotorPower);

	delay(1);
}
